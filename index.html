<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand Gesture AI</title>
    <!-- Standard Font for Body -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600&display=swap" rel="stylesheet">
    <!-- Custom Display Font for Titles -->
    <link rel="stylesheet" href="https://use.typekit.net/xvz5lzf.css">
    
    <style>
        :root {
            --primary: #007bff;
            --background: #000000;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Montserrat', sans-serif;
            background: var(--background);
            color: white;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            position: relative;
        }

        /* Camera Container */
        .camera-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: black;
        }

        video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            transition: filter 0.5s ease;
            filter: brightness(1) grayscale(0);
        }

        /* Class to dim video when gesture is found */
        video.dimmed {
            filter: brightness(0.3) grayscale(0.4);
        }

        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform: scaleX(-1);
            object-fit: cover;
            z-index: 5;
        }

        /* Overlay for loading state */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            color: white;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255,255,255,0.1);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 12px 30px;
            font-size: 14px;
            border-radius: 30px;
            cursor: pointer;
            letter-spacing: 1px;
            text-transform: uppercase;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Fullscreen Toggle Button */
        #fullscreen_btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 15;
            width: 40px;
            height: 40px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            border-radius: 50%;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* Floating Text Area */
        .info-panel {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            z-index: 10;
            text-align: center;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .gesture-icon {
            font-size: 40px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
            opacity: 0;
            transition: opacity 1s ease;
        }

        .gesture-title {
            font-family: "p22-flw-exhibition", sans-serif;
            font-weight: 400;
            font-style: normal;
            font-size: 42px;
            margin: 0 0 5px 0; /* Reduced margin for subtitle */
            color: #fff;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            letter-spacing: 1px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 1s ease;
        }

        /* New Origin Subtitle Style */
        .gesture-origin {
            font-family: 'Montserrat', sans-serif;
            font-weight: 500;
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: #F56B99; /* Matching the bubble color for accent */
            margin: 0 0 15px 0;
            opacity: 0;
            transform: translateY(20px);
            transition: all 1s ease 0.1s;
        }

        .gesture-desc {
            font-family: "rockwell", sans-serif;
            font-weight: 400;
            font-style: normal;
            font-size: 16px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.9);
            margin: 0;
            text-shadow: 0 2px 8px rgba(0,0,0,0.8);
            opacity: 0;
            transform: translateY(20px);
            transition: all 1s ease 0.2s;
        }
        
        /* CTA Arrow & Text */
        .cta-container {
            margin-top: 20px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 1s ease 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .cta-arrow {
            font-size: 24px;
            color: #F56B99;
            animation: bounce 1.5s infinite;
        }

        .cta-text {
            font-family: 'Montserrat', sans-serif;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.9);
            margin-top: 5px;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        /* Active state for text animations */
        .info-panel.active .gesture-icon,
        .info-panel.active .gesture-title,
        .info-panel.active .gesture-origin,
        .info-panel.active .gesture-desc,
        .info-panel.active .cta-container {
            opacity: 1;
            transform: translateY(0);
        }

        /* Idle Prompt Styling */
        .idle-prompt {
            position: absolute;
            top: 35%; 
            left: 26%; /* Moved left from 35% */
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            z-index: 8;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .idle-prompt.visible {
            opacity: 1;
        }

        .idle-prompt h1 {
            font-family: "p22-flw-exhibition", sans-serif;
            font-weight: 400;
            font-style: normal;
            font-size: 90px;
            color: rgba(255, 255, 255, 1);
            margin: 0;
            line-height: 1;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 2;
        }

        .idle-prompt h2 {
            font-family: "p22-flw-exhibition", sans-serif;
            font-weight: 400;
            font-style: normal;
            font-size: 40px;
            color: rgba(255, 255, 255, 0.9);
            margin: 0 0 10px 0;
            z-index: 2;
        }
        
        .idle-prompt p {
            font-size: 24px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 300;
            letter-spacing: 10px;
            margin-top: 5px;
            z-index: 2;
        }

        /* Pink Bubble Background */
        .idle-bg-bubble-sharp {
            position: absolute;
            width: 400px;
            height: 400px;
            background-color: #F56B99;
            border-radius: 50%;
            z-index: 1; 
            top: 15%; 
            left: 10%; 
            transform: translate(-30%, -40%); 
            mix-blend-mode: screen;
        }

        #error_msg {
            color: #ff6b6b;
            font-size: 12px;
            margin-top: 10px;
            max-width: 80%;
        }
    </style>
</head>
<body>

    <!-- Camera View -->
    <div class="camera-container">
        <video id="webcam" playsinline autoplay muted></video>
        <canvas id="output_canvas"></canvas>
        
        <button id="fullscreen_btn" title="Toggle Fullscreen">‚õ∂</button>
        
        <!-- Idle Prompt (Visible when no gesture) -->
        <div id="idle_prompt" class="idle-prompt visible">
            <!-- Background Pink Circle -->
            <div class="idle-bg-bubble-sharp"></div>
            
            <h1>Wave</h1>
            <h2>to begin</h2>
            <p>üëã ‚úåÔ∏è üëç ‚úã ‚úä</p>
        </div>

        <!-- Loading Overlay -->
        <div id="loading_overlay" class="overlay">
            <div class="spinner"></div>
            <p id="status_text">Initializing Experience...</p>
            <div id="error_msg"></div>
            <button id="enable_cam_btn" style="display:none;">Begin Experience</button>
        </div>
    </div>

    <!-- Info Panel -->
    <div id="info_panel" class="info-panel">
        <div id="icon_display" class="gesture-icon"></div>
        <h2 id="title_display" class="gesture-title"></h2>
        <!-- New Origin Subtitle -->
        <h3 id="origin_display" class="gesture-origin"></h3>
        <p id="desc_display" class="gesture-desc"></p>
        <!-- New CTA -->
        <div class="cta-container">
            <div class="cta-arrow">‚Üë</div>
            <div class="cta-text">Check our map for more info</div>
        </div>
    </div>

    <!-- MediaPipe Import -->
    <script type="module">
        import {
            GestureRecognizer,
            FilesetResolver
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        const video = document.getElementById("webcam");
        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");
        const overlay = document.getElementById("loading_overlay");
        const statusText = document.getElementById("status_text");
        const errorMsg = document.getElementById("error_msg");
        const enableBtn = document.getElementById("enable_cam_btn");
        const fullscreenBtn = document.getElementById("fullscreen_btn");
        const infoPanel = document.getElementById("info_panel");
        const idlePrompt = document.getElementById("idle_prompt");
        
        // UI Elements
        const titleDisplay = document.getElementById("title_display");
        const originDisplay = document.getElementById("origin_display"); // New Element
        const descDisplay = document.getElementById("desc_display");
        const iconDisplay = document.getElementById("icon_display");

        let gestureRecognizer;
        let runningMode = "VIDEO";
        let lastVideoTime = -1;
        let isWebcamActive = false;
        let particles = []; 

        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4], 
            [0, 5], [5, 6], [6, 7], [7, 8], 
            [5, 9], [9, 10], [10, 11], [11, 12], 
            [9, 13], [13, 14], [14, 15], [15, 16], 
            [13, 17], [0, 17], [17, 18], [18, 19], [19, 20]
        ];

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 1.5;
                this.vy = (Math.random() - 1.5) * 1.5; 
                this.life = 1.0;
                this.decay = Math.random() * 0.02 + 0.01;
                
                const rand = Math.random();
                let colorBase;
                if (rand < 0.50) colorBase = "254, 246, 227"; 
                else if (rand < 0.70) colorBase = "239, 148, 32";
                else if (rand < 0.90) colorBase = "245, 107, 153";
                else colorBase = "125, 166, 218";

                this.color = `rgba(${colorBase},`;
                this.size = Math.random() * 4 + 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.size *= 0.95; 
            }

            draw(ctx) {
                ctx.fillStyle = this.color + this.life + ')';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Updated Educational Database
        const gestureData = {
            "None": { icon: "", title: "", origin: "", desc: "" },
            
            "Closed_Fist": {
                icon: "‚úä",
                title: "Raised Fist",
                origin: "Europe",
                desc: "Originating in European labor movements, it symbolizes solidarity and resistance. Today, it is widely recognized as a gesture of protest, unity, and empowerment."
            },
            "Open_Palm": {
                icon: "‚úã",
                title: "Palm Out (Stop)",
                origin: "Ancient Greece / Rome",
                desc: "Used since ancient times to signal warning or refusal, it is now standard in traffic control. Today, it is universally recognized as a sign to stop or show caution."
            },
            "Pointing_Up": {
                icon: "‚òùÔ∏è",
                title: "Pointing Up",
                origin: "Universal",
                desc: "A fundamental human gesture used to draw attention upwards. It is commonly used to ask a question, signal direction, or emphasize a point."
            },
            "Thumb_Down": {
                icon: "üëé",
                title: "Thumbs Down",
                origin: "Ancient Rome",
                desc: "Associated with Roman gladiatorial games indicating disapproval. Today, it universally signifies disagreement, disapproval, or a negative response."
            },
            "Thumb_Up": {
                icon: "üëç",
                title: "Thumbs Up",
                origin: "Ancient Rome",
                desc: "Rooted in ancient Rome and widely adopted in the 20th century. Today, it is a globally recognized gesture for positivity, approval, and encouragement."
            },
            "Victory": {
                icon: "‚úåÔ∏è",
                title: "Peace Sign",
                origin: "Belgium",
                desc: "Originating as a WWII resistance symbol, it was later embraced by anti-war activists. Today, it is a global gesture for optimism, celebration, and solidarity."
            },
            "ILoveYou": {
                icon: "ü§ü",
                title: "I Love You",
                origin: "USA (ASL)",
                desc: "Originating from American Sign Language, it combines the letters I, L, and Y. Today, it is recognized globally as a gesture expressing love and affection."
            },
            "Handshake": {
                icon: "ü§ù",
                title: "Handshake",
                origin: "Ancient Greece / Rome",
                desc: "Dates back to ancient civilizations symbolizing peace and trust. Today, it remains a widely recognized gesture of greeting, respect, and mutual agreement."
            },
            "OK": {
                icon: "üëå",
                title: "OK Sign",
                origin: "USA",
                desc: "Rooted in the 1839 U.S. abbreviation for 'all correct,' it signals approval. Today, it generally means agreement, though it carries offensive meanings in some regions."
            },
            // REMOVED ROCK
            // "Rock": { ... }, 
            "Three": {
                icon: "3Ô∏è‚É£",
                title: "Three",
                origin: "Universal",
                desc: "A standard counting gesture used to represent the number three. It represents a specific quantity or the concept of a trinity."
            },
            "Four": {
                icon: "4Ô∏è‚É£",
                title: "Four",
                origin: "Universal",
                desc: "A standard counting gesture used to represent the number four. It represents stability and a specific quantity in visual communication."
            },
             "Shaka": {
                icon: "ü§ô",
                title: "Shaka",
                origin: "Hawaii",
                desc: "Originating in Hawaii as a symbol of the 'aloha spirit,' it spread through surf culture. Today, it signals friendliness, gratitude, and relaxed positivity."
            },
            "Finger_Gun": {
                icon: "üëâ",
                title: "Finger Gun",
                origin: "USA",
                desc: "Emerging in 20th-century Western pop culture, it mimics a gun as a playful sign. Today, it signals friendliness or joking intent, though context is crucial."
            },
            "Fist_Bump": {
                icon: "üëä",
                title: "Fist Bump",
                origin: "USA",
                desc: "Originating in the late 20th century as a hygienic alternative to the handshake. Today, it is a gesture of camaraderie, respect, and friendly acknowledgment."
            },
            "Finger_Crossed": {
                icon: "ü§û",
                title: "Crossed Fingers",
                origin: "Europe",
                desc: "Originating in early Christianity to invoke protection and luck. Today, it is widely used to wish for hope or positive outcomes."
            }
        };

        fullscreenBtn.addEventListener("click", () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {});
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
            }
        });

        const createGestureRecognizer = async () => {
            try {
                statusText.innerText = "Connecting to the Ether...";
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
                );
                
                statusText.innerText = "Awakening AI...";
                
                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath:
                            "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                        delegate: "CPU"
                    },
                    runningMode: runningMode,
                    numHands: 1
                });
                
                statusText.innerText = "Ready.";
                overlay.querySelector(".spinner").style.display = "none";
                enableBtn.style.display = "inline-block";
                
            } catch (error) {
                overlay.querySelector(".spinner").style.borderTopColor = "red";
                overlay.querySelector(".spinner").style.animation = "none";
                statusText.innerText = "Connection Failed";
                errorMsg.innerText = error.message;
            }
        };

        createGestureRecognizer();

        const enableCam = () => {
            if (!gestureRecognizer) return;

            const constraints = {
                video: {
                    facingMode: "user",
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };

            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
                overlay.style.display = "none";
                isWebcamActive = true;
            }).catch((err) => {
                alert("Camera access denied. Please allow permission.");
            });
        };

        enableBtn.addEventListener("click", enableCam);

        // --- GEOMETRIC GESTURE LOGIC ---
        function calculateFingerStates(landmarks) {
            // Finger Tip Indices: 8 (Index), 12 (Middle), 16 (Ring), 20 (Pinky)
            // Finger PIP Indices (Knuckles): 6, 10, 14, 18
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            const extended = [];
            
            // Wrist (0) is anchor. If distance(Wrist, Tip) > distance(Wrist, PIP), finger is extended
            const wrist = landmarks[0];
            for (let i = 0; i < 4; i++) {
                const tip = landmarks[tips[i]];
                const pip = landmarks[pips[i]];
                
                const distTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                const distPip = Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
                
                extended.push(distTip > distPip); 
            }
            
            // Thumb Check: Tip (4), IP (3), Pinky MCP (17) as anchor
            const thumbTip = landmarks[4];
            const thumbIP = landmarks[3];
            const pinkyMCP = landmarks[17];
            
            const distThumbTip = Math.hypot(thumbTip.x - pinkyMCP.x, thumbTip.y - pinkyMCP.y);
            const distThumbIP = Math.hypot(thumbIP.x - pinkyMCP.x, thumbIP.y - pinkyMCP.y);
            
            const thumbUp = distThumbTip > distThumbIP;

            return {
                index: extended[0],
                middle: extended[1],
                ring: extended[2],
                pinky: extended[3],
                thumb: thumbUp
            };
        }
        
        function detectCustomGestures(landmarks, defaultCategory) {
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            
            const states = calculateFingerStates(landmarks);
            const numFingersUp = (states.index?1:0) + (states.middle?1:0) + (states.ring?1:0) + (states.pinky?1:0);
            
            // 1. HANDSHAKE (Rotated Open Palm)
            if (defaultCategory === "Open_Palm" || defaultCategory === "None") {
                const xDiff = Math.abs(indexTip.x - wrist.x);
                const yDiff = Math.abs(indexTip.y - wrist.y);
                if (xDiff > yDiff * 1.5 && numFingersUp >= 3) {
                    return "Handshake";
                }
            }
            
            // 2. FIST BUMP (Rotated Closed Fist)
            const indexMCP = landmarks[5];
            const handIsHorizontal = Math.abs(indexMCP.x - wrist.x) > Math.abs(indexMCP.y - wrist.y) * 1.2;
            
            if (numFingersUp === 0) { 
                 if (handIsHorizontal) {
                     return "Fist_Bump";
                 }
            }
            if ((defaultCategory === "Thumb_Up" || defaultCategory === "Thumb_Down" || defaultCategory === "Closed_Fist") && handIsHorizontal) {
                const thumbYDiff = Math.abs(thumbTip.y - indexMCP.y);
                if (thumbYDiff < 0.1) { 
                    return "Fist_Bump";
                }
            }

            // 3. OK SIGN
            const thumbIndexDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            if (thumbIndexDist < 0.08 && states.middle && states.ring && states.pinky && !states.index) {
                return "OK";
            }

            // 4. ROCK / HORNS -- REMOVED for I LOVE YOU
            // if (states.index && !states.middle && !states.ring && states.pinky) {
            //     return "Rock";
            // }
            
            // 5. SHAKA (Call Me)
            if (!states.index && !states.middle && !states.ring && states.pinky && states.thumb) {
                return "Shaka";
            }

             // 6. I LOVE YOU (ASL)
             // Thumb, Index, Pinky UP. Middle, Ring DOWN.
            if (states.thumb && states.index && !states.middle && !states.ring && states.pinky) {
                return "ILoveYou";
            }
            
            // 7. FINGER GUN
            if (states.thumb && states.index && !states.middle && !states.ring && !states.pinky) {
                return "Finger_Gun";
            }
            
            // 8. FINGER CROSSED (Hope)
            if (states.index && states.middle && !states.ring && !states.pinky) {
                const tipDist = Math.hypot(indexTip.x - middleTip.x, indexTip.y - middleTip.y);
                const pipDist = Math.hypot(landmarks[6].x - landmarks[10].x, landmarks[6].y - landmarks[10].y);
                
                if (tipDist < 0.05 && tipDist < pipDist * 0.65) { 
                    return "Finger_Crossed";
                }
            }

            // 9. NUMBERS (Three, Four)
            if (defaultCategory === "None" || defaultCategory === "Open_Palm") {
                if (numFingersUp === 3) return "Three";
                if (numFingersUp === 4 && !states.thumb) return "Four";
            }

            return defaultCategory;
        }


        async function predictWebcam() {
            if (runningMode === "IMAGE") {
                runningMode = "VIDEO";
                await gestureRecognizer.setOptions({ runningMode: "VIDEO" });
            }

            try {
                if (video.videoWidth > 0 && video.videoHeight > 0) {
                    const displayWidth = video.clientWidth;
                    const displayHeight = video.clientHeight;
                    if (canvasElement.width !== displayWidth || canvasElement.height !== displayHeight) {
                        canvasElement.width = displayWidth;
                        canvasElement.height = displayHeight;
                    }
                    
                    let nowInMs = Date.now();
                    if (video.currentTime !== lastVideoTime) {
                        lastVideoTime = video.currentTime;
                        
                        const results = gestureRecognizer.recognizeForVideo(video, nowInMs);

                        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                        
                        if (results.landmarks && results.landmarks.length > 0) {
                            const landmarks = results.landmarks[0];
                            
                            video.classList.add("dimmed");
                            idlePrompt.classList.remove("visible");

                            canvasCtx.save();
                            canvasCtx.strokeStyle = "#FEF6E3";
                            canvasCtx.lineWidth = 2;
                            canvasCtx.lineCap = "round";
                            canvasCtx.globalAlpha = 0.6; 

                            for (const connection of HAND_CONNECTIONS) {
                                const start = landmarks[connection[0]];
                                const end = landmarks[connection[1]];
                                if (start && end) {
                                    canvasCtx.beginPath();
                                    canvasCtx.moveTo(start.x * canvasElement.width, start.y * canvasElement.height);
                                    canvasCtx.lineTo(end.x * canvasElement.width, end.y * canvasElement.height);
                                    canvasCtx.stroke();
                                }
                            }
                            canvasCtx.restore();

                            for (let i = 0; i < landmarks.length; i++) {
                                const x = landmarks[i].x * canvasElement.width;
                                const y = landmarks[i].y * canvasElement.height;

                                canvasCtx.beginPath();
                                canvasCtx.arc(x, y, 3, 0, 2 * Math.PI);
                                canvasCtx.fillStyle = "#FEF6E3";
                                canvasCtx.fill();

                                if (Math.random() > 0.75) { 
                                    particles.push(new Particle(x, y));
                                }
                            }
                            
                            let categoryName = "None";
                            if (results.gestures.length > 0) {
                                categoryName = results.gestures[0][0].categoryName;
                            }
                            
                            categoryName = detectCustomGestures(landmarks, categoryName);
                            
                            updateUI(categoryName);

                        } else {
                            video.classList.remove("dimmed");
                            idlePrompt.classList.add("visible");
                            updateUI("None");
                        }

                        canvasCtx.globalCompositeOperation = 'lighter'; 
                        for (let i = particles.length - 1; i >= 0; i--) {
                            particles[i].update();
                            particles[i].draw(canvasCtx);
                            if (particles[i].life <= 0) particles.splice(i, 1);
                        }
                        canvasCtx.globalCompositeOperation = 'source-over'; 
                    }
                }
            } catch (err) {
                console.error("Frame processing error:", err);
            }

            if (isWebcamActive) {
                window.requestAnimationFrame(predictWebcam);
            }
        }

        let currentGesture = "None";
        
        function updateUI(category) {
            if (category === currentGesture) return;
            currentGesture = category;

            const data = gestureData[category] || gestureData["None"];

            if (category === "None") {
                infoPanel.classList.remove("active");
            } else {
                titleDisplay.innerText = data.title;
                originDisplay.innerText = data.origin;
                descDisplay.innerText = data.desc;
                iconDisplay.innerText = data.icon;
                infoPanel.classList.add("active");
            }
        }
    </script>
</body>
</html>
