<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand Gesture AI</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #007bff;
            --background: #000000;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Montserrat', sans-serif;
            background: var(--background);
            color: white;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            position: relative;
        }

        /* Camera Container */
        .camera-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: black;
        }

        video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            transition: filter 1s ease; /* Smooth dimming transition */
            filter: brightness(1) grayscale(0);
        }

        /* Class to dim video when gesture is found */
        video.dimmed {
            filter: brightness(0.3) grayscale(0.4);
        }

        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform: scaleX(-1);
            object-fit: cover;
            z-index: 5;
        }

        /* Overlay for loading state */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            color: white;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255,255,255,0.1);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 12px 30px;
            font-size: 14px;
            border-radius: 30px;
            cursor: pointer;
            letter-spacing: 1px;
            text-transform: uppercase;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Fullscreen Toggle Button */
        #fullscreen_btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 15;
            width: 40px;
            height: 40px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            border-radius: 50%;
        }

        /* Floating Text Area - No Background */
        .info-panel {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            z-index: 10;
            text-align: center;
            pointer-events: none; /* Let clicks pass through */
        }

        .gesture-icon {
            font-size: 40px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .gesture-title {
            font-size: 32px;
            font-weight: 600;
            margin: 0 0 10px 0;
            color: #fff;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            letter-spacing: -0.5px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
        }

        .gesture-desc {
            font-size: 16px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.8);
            margin: 0;
            font-weight: 300;
            text-shadow: 0 2px 8px rgba(0,0,0,0.8);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease 0.1s; /* Slight delay */
        }
        
        /* Active state for text animations */
        .info-panel.active .gesture-icon,
        .info-panel.active .gesture-title,
        .info-panel.active .gesture-desc {
            opacity: 1;
            transform: translateY(0);
        }

        #error_msg {
            color: #ff6b6b;
            font-size: 12px;
            margin-top: 10px;
            max-width: 80%;
        }
    </style>
</head>
<body>

    <!-- Camera View -->
    <div class="camera-container">
        <video id="webcam" playsinline autoplay muted></video>
        <canvas id="output_canvas"></canvas>
        
        <button id="fullscreen_btn" title="Toggle Fullscreen">â›¶</button>

        <!-- Loading Overlay -->
        <div id="loading_overlay" class="overlay">
            <div class="spinner"></div>
            <p id="status_text">Initializing Experience...</p>
            <div id="error_msg"></div>
            <button id="enable_cam_btn" style="display:none;">Begin Experience</button>
        </div>
    </div>

    <!-- Info Panel -->
    <div id="info_panel" class="info-panel">
        <div id="icon_display" class="gesture-icon"></div>
        <h2 id="title_display" class="gesture-title"></h2>
        <p id="desc_display" class="gesture-desc"></p>
    </div>

    <!-- MediaPipe Import -->
    <script type="module">
        import {
            GestureRecognizer,
            FilesetResolver
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        const video = document.getElementById("webcam");
        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");
        const overlay = document.getElementById("loading_overlay");
        const statusText = document.getElementById("status_text");
        const errorMsg = document.getElementById("error_msg");
        const enableBtn = document.getElementById("enable_cam_btn");
        const fullscreenBtn = document.getElementById("fullscreen_btn");
        const infoPanel = document.getElementById("info_panel");
        
        // UI Elements
        const titleDisplay = document.getElementById("title_display");
        const descDisplay = document.getElementById("desc_display");
        const iconDisplay = document.getElementById("icon_display");

        let gestureRecognizer;
        let runningMode = "VIDEO";
        let lastVideoTime = -1;
        let isWebcamActive = false;
        let particles = []; // Array to store particles

        // Particle System Class
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                // Random drift velocity
                this.vx = (Math.random() - 0.5) * 1.5;
                this.vy = (Math.random() - 1.5) * 1.5; // Tendency to float up
                this.life = 1.0;
                this.decay = Math.random() * 0.02 + 0.01;
                // Beautiful ethereal colors (Cyan, Purple, White)
                const hue = Math.random() > 0.5 ? 180 + Math.random() * 40 : 260 + Math.random() * 40;
                this.color = `hsla(${hue}, 80%, 70%,`;
                this.size = Math.random() * 3 + 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.size *= 0.95; // Shrink over time
            }

            draw(ctx) {
                ctx.fillStyle = this.color + this.life + ')';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Content Database
        const gestureData = {
            "None": {
                icon: "",
                title: "",
                desc: ""
            },
            "Closed_Fist": {
                icon: "âœŠ",
                title: "Strength",
                desc: "A closed form holds potential. It represents solidarity, determination, and the power within."
            },
            "Open_Palm": {
                icon: "âœ‹",
                title: "Openness",
                desc: "To open one's hand is to release control. It is the universal sign of greeting, honesty, and peace."
            },
            "Pointing_Up": {
                icon: "â˜ï¸",
                title: "Direction",
                desc: "A singular focus towards the heavens. It asks a question or highlights a truth above."
            },
            "Thumb_Down": {
                icon: "ðŸ‘Ž",
                title: "Dissent",
                desc: "A judgment passed. It signifies disagreement, a turning away from the current path."
            },
            "Thumb_Up": {
                icon: "ðŸ‘",
                title: "Accord",
                desc: "Harmony with the situation. A simple gesture of approval, connection, and positivity."
            },
            "Victory": {
                icon: "âœŒï¸",
                title: "Peace",
                desc: "The dual path. Whether victory or peace, it represents triumph over conflict."
            },
            "ILoveYou": {
                icon: "ðŸ¤Ÿ",
                title: "Affection",
                desc: "The language of the heart made visible. A combination of letters that forms a universal bond."
            }
        };

        // Fullscreen Logic
        fullscreenBtn.addEventListener("click", () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

        // 1. Initialize AI
        const createGestureRecognizer = async () => {
            try {
                statusText.innerText = "Connecting to the Ether...";
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
                );
                
                statusText.innerText = "Awakening AI...";
                
                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath:
                            "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                        delegate: "CPU"
                    },
                    runningMode: runningMode,
                    numHands: 1
                });
                
                statusText.innerText = "Ready.";
                overlay.querySelector(".spinner").style.display = "none";
                enableBtn.style.display = "inline-block";
                
            } catch (error) {
                overlay.querySelector(".spinner").style.borderTopColor = "red";
                overlay.querySelector(".spinner").style.animation = "none";
                statusText.innerText = "Connection Failed";
                errorMsg.innerText = error.message;
            }
        };

        createGestureRecognizer();

        // 2. Enable Webcam
        const enableCam = () => {
            if (!gestureRecognizer) return;

            const constraints = {
                video: {
                    facingMode: "user",
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };

            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
                overlay.style.display = "none";
                isWebcamActive = true;
            }).catch((err) => {
                alert("Camera access denied. Please allow permission.");
            });
        };

        enableBtn.addEventListener("click", enableCam);

        // 3. Prediction & Rendering Loop
        async function predictWebcam() {
            if (runningMode === "IMAGE") {
                runningMode = "VIDEO";
                await gestureRecognizer.setOptions({ runningMode: "VIDEO" });
            }

            if (video.videoWidth > 0 && video.videoHeight > 0) {
                // Resize canvas if needed
                const displayWidth = video.clientWidth;
                const displayHeight = video.clientHeight;
                if (canvasElement.width !== displayWidth || canvasElement.height !== displayHeight) {
                     canvasElement.width = displayWidth;
                     canvasElement.height = displayHeight;
                }
                
                let nowInMs = Date.now();
                if (video.currentTime !== lastVideoTime) {
                    lastVideoTime = video.currentTime;
                    
                    // Detect Gestures
                    const results = gestureRecognizer.recognizeForVideo(video, nowInMs);

                    // Clear Canvas for new frame
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                    
                    // --- PARTICLE SYSTEM ---
                    // 1. Spawn new particles if hands detected
                    if (results.landmarks && results.landmarks.length > 0) {
                        const landmarks = results.landmarks[0];
                        
                        // Dim the video because we found a hand
                        video.classList.add("dimmed");

                        // Spawn particles at every landmark
                        // We use a simplified loop to spawn fewer particles for performance
                        for (let i = 0; i < landmarks.length; i++) {
                            // Only spawn random particles (not every frame on every point to avoid clutter)
                            if (Math.random() > 0.7) { 
                                const x = landmarks[i].x * canvasElement.width;
                                const y = landmarks[i].y * canvasElement.height;
                                particles.push(new Particle(x, y));
                            }
                        }
                    } else {
                        // Undim video if no hand
                        video.classList.remove("dimmed");
                    }

                    // 2. Update and Draw all particles
                    // Use 'lighter' blend mode for glowing effect
                    canvasCtx.globalCompositeOperation = 'lighter'; 
                    
                    for (let i = particles.length - 1; i >= 0; i--) {
                        particles[i].update();
                        particles[i].draw(canvasCtx);
                        
                        if (particles[i].life <= 0) {
                            particles.splice(i, 1);
                        }
                    }
                    
                    canvasCtx.globalCompositeOperation = 'source-over'; // Reset blend mode

                    // --- UI UPDATE ---
                    if (results.gestures.length > 0) {
                        const gesture = results.gestures[0][0];
                        updateUI(gesture.categoryName);
                    } else {
                        updateUI("None");
                    }
                }
            }

            if (isWebcamActive) {
                window.requestAnimationFrame(predictWebcam);
            }
        }

        // 4. Update UI
        let currentGesture = "None";
        
        function updateUI(category) {
            // Only update if changed
            if (category === currentGesture) return;
            currentGesture = category;

            const data = gestureData[category] || gestureData["None"];

            if (category === "None") {
                infoPanel.classList.remove("active");
            } else {
                titleDisplay.innerText = data.title;
                descDisplay.innerText = data.desc;
                iconDisplay.innerText = data.icon;
                infoPanel.classList.add("active");
            }
        }
    </script>
</body>
</html>
